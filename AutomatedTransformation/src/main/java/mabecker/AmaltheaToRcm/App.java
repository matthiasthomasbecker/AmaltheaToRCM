/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package mabecker.AmaltheaToRcm;

import java.io.File;

import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.CommandLineParser;
import org.apache.commons.cli.DefaultParser;
import org.apache.commons.cli.Options;
import org.apache.commons.cli.ParseException;
import org.eclipse.app4mc.amalthea.model.Amalthea;
import org.eclipse.app4mc.amalthea.model.io.AmaltheaLoader;

import mabecker.AmaltheaToRcm.transformation.AmaltheaToRCM;

public class App {

	private final static int EXPERIMENT_ROUNDS = 1;
	
    @SuppressWarnings("unused")
	public static void main(String[] args) {
    	
    	Amalthea model = null;
    	Options options = new Options();
    	options.addOption("a", "amalthea", true, "Path to the Amalthea model of the application");
    	
    	CommandLineParser parser = new DefaultParser();
		try {
			CommandLine cmd = parser.parse( options, args);
	    	String amaltheaModel = cmd.getOptionValue("a");
			if (amaltheaModel != null) {
				System.out.println("Model: " + amaltheaModel);
			}
	        
			double[] setupTime = new double[EXPERIMENT_ROUNDS];
			double[] transformationTime = new double[EXPERIMENT_ROUNDS];
			double[] exportTime = new double[EXPERIMENT_ROUNDS];
			double[] totalTime = new double[EXPERIMENT_ROUNDS];
			
			for (int i = 0; i < EXPERIMENT_ROUNDS; i++) {
			
				double startTime = System.nanoTime();
				
		        File inputFile = new File(amaltheaModel);
		        model = null;
		        model = AmaltheaLoader.loadFromFile(inputFile);
		        
		        if (model == null) {
		        	System.err.println("Problem loading the Amalthea model!");
		    		System.exit(1);
		        }
		        
		        AmaltheaToRCM transform = new AmaltheaToRCM(model, getFileNameWithoutExtension(inputFile));
		        
		        double startTransformTime = System.nanoTime();
		        
		        transform.tranformModel();
		        
		        double startExportTime = System.nanoTime();
		        
		        transform.exportRCM();
		        
		        double endTime = System.nanoTime();
		        
		        setupTime[i] = startTransformTime - startTime;
		        transformationTime[i] = startExportTime - startTransformTime;
		        exportTime[i] = endTime - startExportTime;
		        totalTime[i] = endTime - startTime;
	        
			}
			
			if (EXPERIMENT_ROUNDS > 1) {
				double[] resultSetupTime = new double[4];
				double[] resultTransformationTime = new double[4];
				double[] resultExportTime = new double[4];
				double[] resultTotalTime = new double[4];
				
				
				/* Calculate minimum values*/
				resultSetupTime[0] = calculateMin(setupTime);
				resultTransformationTime[0] = calculateMin(transformationTime);
				resultExportTime[0] = calculateMin(exportTime);
				resultTotalTime[0] = calculateMin(totalTime);
				
				/* Calculate maximum values*/
				resultSetupTime[1] = calculateMax(setupTime);
				resultTransformationTime[1] = calculateMax(transformationTime);
				resultExportTime[1] = calculateMax(exportTime);
				resultTotalTime[1] = calculateMax(totalTime);
				
				/* Calculate average values*/
				resultSetupTime[2] = calculateAvrg(setupTime);
				resultTransformationTime[2] = calculateAvrg(transformationTime);
				resultExportTime[2] = calculateAvrg(exportTime);
				resultTotalTime[2] = calculateAvrg(totalTime);
				
				/* Calculate standard deviation values*/
				resultSetupTime[3] = calculateSD(setupTime);
				resultTransformationTime[3] = calculateSD(transformationTime);
				resultExportTime[3] = calculateSD(exportTime);
				resultTotalTime[3] = calculateSD(totalTime);
				
				System.out.println("================================");
				System.out.println("= Measurements [" + EXPERIMENT_ROUNDS + " Experiments]");
				System.out.println("================================");
				
				System.out.println("Setup Time:\t\t" + getResultString(resultSetupTime));
			    System.out.println("Transformation Time:\t" + getResultString(resultTransformationTime)); 
			    System.out.println("Export Time:\t\t" + getResultString(resultExportTime));
				System.out.println("Total Time:\t\t" + getResultString(resultTotalTime));
				
			} else {
				System.out.println("================================");
				System.out.println("= Measurements                 =");
				System.out.println("================================");
				System.out.println("Setup Time:\t\t" + setupTime[0]/1000000 + " ms");
			    System.out.println("Transformation Time:\t" + transformationTime[0]/1000000 + " ms"); System.out.println("Export Time:\t\t" + exportTime[0]/1000000 + " ms");
				System.out.println("Total Time:\t\t" + totalTime[0]/1000000 + " ms");
			}
			
			
			  
			 
	        
		} catch (ParseException e) {
			e.printStackTrace();
		}
    }
    
    public static String getResultString(double result[]) {
    	String retval = "";
    	
    	String minValue = result[0] / 1000000 + " ms";
    	String maxValue = result[1] / 1000000 + " ms";
    	String averValue = result[2] / 1000000 + " ms";
    	String sdValue = result[3] / 1000000 + " ms";
    	
    	retval = minValue + " " + maxValue + " " + averValue + " " + sdValue;
    	
    	return retval;
    }
    
    public static double calculateMin(double numArray[]) {
    	double min = Double.MAX_VALUE;
    	
    	for (double d : numArray) {
			if (d < min) min = d;
		}
    	
    	return min;
    }
    
    public static double calculateMax(double numArray[]) {
    	double max = 0;
    	
    	for (double d : numArray) {
			if (d > max) max = d;
		}
    	
    	return max;
    }

    public static double calculateAvrg(double numArray[]) {
    	double avrg = 0;
    	
    	for (double d : numArray) {
			avrg += d;
		}
    	
    	avrg = avrg / numArray.length;
    	
    	return avrg;
    }

    public static double calculateSD(double numArray[])
    {
        double sum = 0.0, standardDeviation = 0.0;
        int length = numArray.length;

        for(double num : numArray) {
            sum += num;
        }

        double mean = sum/length;

        for(double num: numArray) {
            standardDeviation += Math.pow(num - mean, 2);
        }

        return Math.sqrt(standardDeviation/length);
    }
    
    /**
	 * This method returns the filename of a file without path or extension 
	 * Note: from here https://www.technicalkeeda.com/java-tutorials/get-filename-without-extension-using-java
	 * @param file
	 * @return
	 */
	protected static String getFileNameWithoutExtension(File file) {
        String fileName = "";
 
        try {
            if (file != null && file.exists()) {
                String name = file.getName();
                fileName = name.replaceFirst("[.][^.]+$", "");
            }
        } catch (Exception e) {
            e.printStackTrace();
            fileName = "";
        }
 
        return fileName;
 
    }
}
